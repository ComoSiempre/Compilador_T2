package parser;

import java_cup.runtime.*;
import java.util.ArrayList;
import scanner.*;
import ast.*;
import Tables.*;

/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
	public void report_error(String message, Object info) {
    	    StringBuilder m = new StringBuilder("Error");
        	if (info instanceof java_cup.runtime.Symbol) {
            	java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" en linea "+(s.left+1));
                if (s.right >= 0)
                    m.append(", columna "+(s.right+1));
            }
        }
        m.append(" : "+message);
        //System.err.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        //System.exit(1);
    }
:};

/* ------------Declaracion de simbolos terminales y no terminales---------- */
   
/* Terminales (tokens obtenidos por el analizador lexico).  

   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */
terminal String 	IF,INT,ELSE,RETURN,VOID,WHILE,FOR,SUMA,RESTA,MULTIPLICACION,
					DIVISION,EXPONENCIACION_1,EXPONENCIACION_2,ASSIGN,PARENT_IZQ,
					PARENT_DER,CORCH_IZQ,CORCH_DER,LLAVE_IZQ,LLAVE_DER,MENOR,MENIGUAL,
					MAYOR,MAYIGUAL,IGUALIGUAL,DISTINTO,PUNTOCOMA,COMA;
terminal String 	NUM; //se trabajara como string y se convertira a interger cuando sea nesesario.
terminal String 	ID;	


/* No terminales usados en la seccion gramatical. 

   es esta seccion se listara los objetos Nodo que contendran la gramatica
   y los que tengan un valor Object. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String.
*/
non terminal    Program    program;
non terminal    Program    declaration_list;
non terminal    Nodo    declaration;
non terminal    Nodo    var_declaration;
non terminal    Nodo    fun_declaration;
non terminal    String    type_specifier;
non terminal    Nodo    params;
non terminal    Nodo    param_list;
non terminal    Nodo    param;
non terminal    Nodo    compound_stmt;
non terminal    ArrayList<Nodo>    local_declarations;
non terminal    ArrayList<Nodo>    statement_list;
non terminal    Nodo    statement;
non terminal    expression_stmt;
non terminal    selection_stmt;
non terminal    iteration_stmt;
non terminal    return_stmt;
non terminal    expression;
non terminal    while_stmt;
non terminal    for_stmt;
non terminal    var;
non terminal    simple_expression;
non terminal    additive_expression;
non terminal    String    relop;
non terminal    String    addop;
non terminal    term;
non terminal    String    mulop;
non terminal    factor;
non terminal    String    powop;
non terminal    exp;
non terminal    call;
non terminal    args;
non terminal    arg_list;   
non terminal    empty; //representaria en epsilon en cup.

precedence left ELSE;
start with program;

/* ------------------- Seccion de la gramatica ------------------------ */

program     ::=     declaration_list:dl
                    {:
                        System.out.println("Fin analisis sintactico.");
                        RESULT=dl; //envio la raiz para ser dibujado en grapher
                    :};

declaration_list    ::=     declaration_list:list declaration:d
                            {:
                                if(d != null){
                                    list.agregarDeclaracion(d);
                                }else{
                                    //no deberia llegar nunca aqui.
                                    list = new Program();
                                }
                                RESULT=list;
                            :}
                            |
                            declaration:d
                            {:
                                Program lista = new Program();
                                lista.agregarDeclaracion(d);
                                RESULT=lista;
                            :};

declaration     ::=     var_declaration:v
                        {:
                            RESULT=v;
                        :}
                        |
                        fun_declaration:f
                        {:
                            RESULT=f;
                        :};

var_declaration     ::=     type_specifier:te ID:id PUNTOCOMA
                            {:
                                if(te.equalsIgnoreCase("int")){
                                    RESULT= new VarDec("INT",id, false);
                                }else{
                                    RESULT=new VarDec("VOID",id, false);
                                }
                            :}
                            |
                            type_specifier:te ID:id CORCH_IZQ NUM:num CORCH_DER PUNTOCOMA
                            {:
                                if(te.equalsIgnoreCase("int")){
                                    RESULT= new VarDec("INT", id, true, Integer.parseInt(num));
                                }else{
                                    RESULT=new VarDec("VOID", id, true, Integer.parseInt(num));
                                }
                            :};

type_specifier      ::=     INT:i
                            {:
                                RESULT=i;
                            :}
                            |
                            VOID:v
                            {:
                                RESULT=v;
                            :};

fun_declaration     ::=     type_specifier:t ID:id PARENT_IZQ params:pa PARENT_DER compound_stmt:com
                            {:
                                //ingreso la id al nodo anteriormente creado.
                                ((FunDec) pa).setID(id);
                                //ingreso el tipo de funcion al nodo anteriormente creado.
                                ((FunDec) pa).setTipoFunction(t);

                                //condicionante usado si los componentes existen o no.
                                if(com != null){
                                    ((FunDec) pa).setCompound_stmt(com);
                                }
                                RESULT=(Nodo) pa;

                            :};

params      ::=     param_list:lista
                    {:
                        RESULT=lista;
                    :}
                    |
                    VOID:v
                    {:
                        //se crea el nodo directamente sin parametros.
                        RESULT=new FunDec(true);
                    :};

param_list  ::=     param_list:list COMA param:p
                    {:
                        //condicionante si el parametro no es nulo. en ese caso se agrega a la lista de paramentros del nodo Funcion.
                        if(p != null){
                            ((FunDec)list).agregarParametro(p);
                        }else{
                            //nunca entra aqui.
                            list=new FunDec();
                        }
                        RESULT=list;
                    :}
                    |
                    param:p
                    {:
                        //creo el nodo de la funcion quen contendra la lista de parametros.
                        FunDec list= new FunDec();
                        //agrego el parametro a la lista del nodo.
                        list.agregarParametro(p);
                        RESULT=list;
                    :};

param   ::=     type_specifier:t ID:id
                {:
                    //se crea el nodo parametro.
                    RESULT=new Param(t,id,false);
                :}
                |
                type_specifier:t ID:id CORCH_IZQ CORCH_DER
                {:
                    //se crea el nodo parametro (parametro vector).
                    RESULT=new Param(t, id, true);
                :};

compound_stmt   ::=     LLAVE_IZQ local_declarations:list_dec statement_list:list_sta LLAVE_DER
                        {:
                            RESULT= new Compound(list_dec,list_sta);
                        :};

local_declarations      ::=     local_declarations:list var_declaration:var
                                {:
                                    //condicionante usado si el nodo variable es nulo.
                                    if(var != null){
                                        list.add(var);
                                    }else{
                                        //no entra aqui.
                                        list=new ArrayList<Nodo>();
                                    }
                                    RESULT=list;
                                :}
                                |
                                empty
                                {:
                                    //se crea la lista de nodos de variables locales.
                                    ArrayList<Nodo> list = new ArrayList<Nodo>();
                                    RESULT=list;//se envia la lista creada.
                                :}; 

statement_list      ::=     statement_list:list statement:sta
                            {:
                                //condicionante usado si el nodo Statement es nulo.
                                if(sta != null){
                                    list.add(sta);
                                }else{
                                    //no deberia entrar aqui.
                                    list= new ArrayList<Nodo>();
                                }
                                RESULT=list;
                            :}
                            |
                            empty
                            {:
                                //se crea la lista de nodos de statements.
                                ArrayList<Nodo> list = new ArrayList<Nodo>();
                                RESULT=list;//se envia la lista creada.
                            :};

statement       ::=     expression_stmt
                        {:
                        :}
                        |
                        compound_stmt
                        {:
                        :}
                        |
                        selection_stmt
                        {:
                        :}
                        |
                        iteration_stmt
                        {:
                        :}
                        return_stmt
                        {:
                        :};

expression_stmt     ::=     expression PUNTOCOMA
                            {:
                            :}
                            |
                            PUNTOCOMA
                            {:
                            :};

selection_stmt      ::=     IF PARENT_IZQ expression PARENT_DER statement 
                            {:
                            :}
                            |
                            IF PARENT_IZQ expression PARENT_DER statement ELSE statement
                            {:
                            :};

iteration_stmt      ::=     while_stmt
                            {:
                            :}
                            |
                            for_stmt
                            {:
                            :};

while_stmt      ::=     WHILE PARENT_IZQ expression PARENT_DER statement
                        {:
                        :};

for_stmt        ::=     FOR PARENT_IZQ expression COMA expression COMA expression PARENT_DER statement
                        {:
                        :};

return_stmt     ::=     RETURN PUNTOCOMA
                        {:
                        :}
                        |
                        RETURN expression PUNTOCOMA
                        {:
                        :};

expression      ::=     var ASSIGN expression
                        {:
                        :}
                        |
                        simple_expression
                        {:
                        :};

var         ::=     ID
                    {:
                    :}
                    |
                    ID CORCH_IZQ expression CORCH_DER
                    {:
                    :};

simple_expression       ::=     additive_expression relop additive_expression
                                {:
                                :}
                                |
                                additive_expression
                                {:
                                :};

relop       ::=     MENIGUAL:me
                    {:
                        RESULT=me;
                    :}
                    MENOR:men
                    {:
                        RESULT=men;
                    :}
                    MAYOR:ma
                    {:
                        RESULT=ma;
                    :}
                    MAYIGUAL:may
                    {:
                        RESULT=may;
                    :}
                    IGUALIGUAL:ii
                    {:
                        RESULT=ii;
                    :}
                    DISTINTO:dis
                    {:
                        RESULT=dis;
                    :};

additive_expression     ::=     additive_expression addop term
                                {:
                                :}
                                |
                                term
                                {:
                                :};

addop       ::=     SUMA:sum
                    {:
                        RESULT=sum;
                    :}
                    |
                    RESTA:res
                    {:
                        RESULT=res;
                    :};

term        ::=     term mulop factor
                    {:
                    :}
                    |
                    factor
                    {:
                    :};

mulop       ::=     MULTIPLICACION:mu
                    {:
                        RESULT=mu;
                    :}
                    |
                    DIVISION:div
                    {:
                        RESULT=div;
                    :};

factor      ::=     factor powop exp
                    {:
                    :}
                    |
                    exp
                    {:
                    :};

powop       ::=     EXPONENCIACION_1:exp1 //^
                    {:
                        RESULT=exp1;
                    :}
                    |
                    EXPONENCIACION_2:exp2 //**
                    {:
                        RESULT=exp2;
                    :};                                                                                                                                                                                                                                                                                        

exp         ::=     PARENT_IZQ expression PARENT_DER
                    {:
                    :}
                    |
                    var
                    {:
                    :}
                    |
                    call
                    {:
                    :}
                    |
                    NUM
                    {:
                    :};

call    ::=     ID PARENT_IZQ args PARENT_DER
                {:
                :};

args    ::=     arg_list
                {:
                :}
                |
                empty
                {:
                :};

arg_list    ::=     arg_list COMA expression
                    {:
                    :}
                    |
                    expression
                    {:
                    :};

/* Gramatica nesesaria */
empty   ::= /* vacio */;                                                   